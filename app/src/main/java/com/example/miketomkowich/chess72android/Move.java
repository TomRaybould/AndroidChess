package com.example.miketomkowich.chess72android;

/**
* Move is a class that stores the details of a move generated by a piece
* and is able to make that move by move.makeMove and also undo that move using 
* move.undoMove. The move class can also check is a move puts you in check by calling
* move.moveEndsCheck. Instances of this class are created if the isValidMove method of 
* Piece determines that the destination is a valid move for that piece.
* 
* @author  Tom Raybould & Mike Tomkowich
*/
import java.util.Stack;

public class Move {
	
	private Piece movePiece;
	private int ogRow;
	private int ogCol;
	private int destRow;
	private int destCol;
	private Piece takenPiece;
	private int takenRow;
	private int takenCol;
	
	private boolean isEmpass;
	private boolean isPromote;
	private boolean isCastle;
	
	private static Stack<Move> moveLog = new Stack<Move>();
	
	public boolean getIsPromote(){
		return isPromote;
	}
	
	//if is castle, taken should equal the rook involved
	 
	public static Move getLastMove(){
		Move lastMove= moveLog.peek();
		return lastMove;
	}
	
	public Piece getMovedPiece(){
		return this.movePiece;
	}
	
	public Move(Piece moving, int destRow, int destCol, Piece taken, boolean isEmpass, boolean isPromote, boolean isCastle) {
		
		this.movePiece = moving;
		this.ogRow = moving.getRow();
		this.ogCol = moving.getCol();
		this.destRow = destRow;
		this.destCol = destCol;
		this.takenPiece = taken;
		this.isEmpass = isEmpass;
		this.isPromote = isPromote;
		this.isCastle= isCastle;
		if(takenPiece!=null){
			this.takenRow=this.takenPiece.getRow();
			this.takenCol=this.takenPiece.getCol();
		}
		
	}
	
	@Override
	public String toString() {
		return "Move [movePiece=" + movePiece + ", ogRow=" + ogRow + ", ogCol=" + ogCol + ", destRow=" + destRow + ", destCol="
				+ destCol + ", takenPiece=" + takenPiece + ", takenRow=" + takenRow + ", takenCol=" + takenCol + ", isEmpass="
				+ isEmpass + ", isPromote=" + isPromote + ", isCastle=" + isCastle + "]";
	}
	/**
	   * This method takes the current state of the board and called on the move object.
	   * It returns void. This method is responsible for moving pieces on the board
	   * (in the board array). It takes in consideration of all special cases(promotion, 
	   * en passant and castle). Which are denoted by marker booleans in object (isPromote...).
	   * These marker booleans were set to true in when the constructor was called in the 
	   * isValidMove method of Piece, if it was determined that the move is one of these
	   * special cases, the marker is set to true. In words special cases handle in the logic of 
	   * isValidMove and the markers are set so the move instance knows how to make and undo those moves.
	   * Increments the moveCount in the piece involved in the move.
	   * 
	   * @param gameBoard The current state of the board for both players
	   * @return void
	*/
	public void makeMove(Board gameBoard){
		Piece [][] board = gameBoard.getBoard();
		if(this.isEmpass){
			board[this.ogRow][this.ogCol]= null;//set og spot to null
			board[this.destRow][this.destCol] = this.movePiece; //move piece
			board[this.takenRow][this.takenCol]= null; // set the taken pawns place to null
			this.movePiece.setRow(this.destRow);
			this.movePiece.setCol(this.destCol);
			this.movePiece.setMoveCounter(movePiece.getMoveCounter()+1);
			moveLog.push(this);
			return;
		}
		else if(this.isPromote){
			board[this.ogRow][this.ogCol]= null;
			board[this.destRow][this.destCol] = this.movePiece;
			this.movePiece.setRow(this.destRow);
			this.movePiece.setCol(this.destCol);
			this.movePiece.setMoveCounter(movePiece.getMoveCounter()+1);
			moveLog.push(this);
			return;
		}
		else if(this.isCastle){
			//move the king
			board[this.ogRow][this.ogCol] = null;
			board[this.destRow][this.destCol] = this.movePiece;
			this.movePiece.setRow(this.destRow);
			this.movePiece.setCol(this.destCol);
			this.movePiece.setMoveCounter(movePiece.getMoveCounter()+1);;
			//move the rook
			if(this.destCol == 6){
				board[this.destRow][7] = null;
				board[this.destRow][5] = this.takenPiece;
				this.takenPiece.setRow(this.destRow);
				this.takenPiece.setCol(5);
				this.takenPiece.setMoveCounter(takenPiece.getMoveCounter()+1);
				moveLog.push(this);
				return;
			}
			
			else if(this.destCol==2){
				board[this.destRow][0] = null;
				board[this.destRow][3] = this.takenPiece;
				this.takenPiece.setRow(this.destRow);
				this.takenPiece.setCol(3);
				this.takenPiece.setMoveCounter(takenPiece.getMoveCounter()+1);
				moveLog.push(this);
				return;
			}
		}
		else{
			//regular move
			board[this.ogRow][this.ogCol] = null;
			board[this.destRow][this.destCol] = this.movePiece;
			this.movePiece.setRow(this.destRow);
			this.movePiece.setCol(this.destCol);
			this.movePiece.setMoveCounter(movePiece.getMoveCounter()+1);;
			moveLog.push(this);
			return;
		}
		
	}
	/**
	   * This method takes in the current board and a player object. If the player's
	   * move ends check, it will return true. If it doesn't end check, it will return false.
	   * In other words if you are still in check/or put in check after this move it returns
	   * false.
	   * @param b The current state of the board for both players 
	   * @param p The player object 
	   * @return boolean true only if the player is not in check after the move is made
	   * @see Player.isInCheck
	*/
	public boolean moveEndsCheck(Board b, Player p){//returns false if you are in check after the move
		this.makeMove(b);
		if (p.isInCheck(b)){
			this.undoMove(b);
			return false;
		}
		else{
			this.undoMove(b);
			return true;
		}
	}
	
	/**
	   * This method takes in the current board. It returns nothing. The purpose of the method
	   * is to undo moves. This is done to help other methods such as check and check mate to check to 
	   * see if certain moves will put a player into check and check mate
	   * 
	   * Decrements the moveCount in the piece involved in the move.
	   * 
	   * @param gameBoard The current state of the board for both players
	   * @return void
	*/
	public void undoMove(Board gameBoard){
		Piece [][] board = gameBoard.getBoard();
		
		if(this.isEmpass){
			board[this.ogRow][this.ogCol] = this.movePiece;
			board[this.destRow][this.destCol]=null;
			board[this.takenRow][this.takenCol]=this.takenPiece;
			this.movePiece.setRow(this.ogRow);
			this.movePiece.setCol(this.ogCol);
			this.movePiece.setMoveCounter(movePiece.getMoveCounter()-1);
			moveLog.pop();
			return;	
		}
		
		else if(this.isPromote){
			
			board[this.ogRow][this.ogCol]= this.movePiece;
			board[this.destRow][this.destCol] = this.takenPiece;
			this.movePiece.setRow(this.ogRow);
			this.movePiece.setCol(this.ogCol);
			this.movePiece.setMoveCounter(movePiece.getMoveCounter()-1);
			moveLog.pop();
			return;
		}
		else if(this.isCastle){
			//move king back
			board[this.ogRow][this.ogCol] = movePiece;
			board[this.destRow][this.destCol] = null;
			this.movePiece.setRow(this.ogRow);
			this.movePiece.setCol(this.ogCol);
			this.movePiece.setMoveCounter(movePiece.getMoveCounter()-1);
			//move the rook back
			board[this.takenPiece.getRow()][this.takenPiece.getCol()] = null;
			board[this.takenRow][this.takenCol]=this.takenPiece;
			this.takenPiece.setRow(takenRow);
			this.takenPiece.setCol(takenCol);
			this.takenPiece.setMoveCounter(takenPiece.getMoveCounter()-1);
			moveLog.pop();
			return;
		}
	
		else{
			board[this.ogRow][this.ogCol] = movePiece;
			board[this.destRow][this.destCol] = this.takenPiece;
			this.movePiece.setRow(this.ogRow);
			this.movePiece.setCol(this.ogCol);
			this.movePiece.setMoveCounter(movePiece.getMoveCounter()-1);
			moveLog.pop();
			return;
		}	
	}
	
}